{
  "$schema": {
      "desc": "http://json-schema.org/draft-04/schema#"
  },
  "id": {
      "desc": "https://json.schemastore.org/codecov"
  },
  "description": {
      "desc": "The Codecov configuration file is used to configure your Codecov experience. More info: https://docs.codecov.com/docs/codecov-yaml"
  },
  "codecov.url": {
      "desc": "pattern: https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*), description: "
  },
  "codecov.token": {
      "desc": "The repository upload token. More info: https://docs.codecov.com/docs/codecov-uploader#upload-token"
  },
  "codecov.slug": {
      "desc": "description: "
  },
  "codecov.bot": {
      "desc": "The username you want to use for Codecov operations. More info: https://docs.codecov.com/docs/team-bot"
  },
  "codecov.branch": {
      "desc": "description: "
  },
  "codecov.ci": {
      "desc": "Additional CI provider URLs you want Codecov to recognize. More info: https://docs.codecov.com/docs/detecting-ci-services"
  },
  "codecov.assume_all_flags": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.strict_yaml_branch": {
      "desc": "Specify a branch you want Codecov to always only read the YAML from. More info: https://docs.codecov.io/docs/codecov-yaml#section-restricting-changes"
  },
  "codecov.max_report_age": {
      "desc": "The age you want coverage reports to expire at, or if you want to disable this check. Expired reports will not be processed by codecov. More info: https://docs.codecov.io/docs/codecov-yaml#section-expired-reports"
  },
  "codecov.disable_default_path_fixes": {
      "desc": "Should Codecov's default path fixes be disabled. More info: https://docs.codecov.io/docs/fixing-paths. Enum: True,  False,  yes,  no,  on,  off"
  },
  "codecov.require_ci_to_pass": {
      "desc": "Should Codecov wait for all other statuses to pass before sending its status. Enum: True, False,  yes,  no,  on,  off"
  },
  "codecov.allow_coverage_offsets": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.allow_pseudo_compare": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.archive.uploads": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.archive": {
      "desc": "Configure cloud report archiving. Enum: True, False, yes, no, on, off"
  },
  "codecov.notify.after_n_builds": {
      "desc": "How many uploaded reports Codecov should wait to receive before sending statuses. More info: https://docs.codecov.io/docs/notifications#section-preventing-notifications-until-after-n-builds."
  },
  "codecov.notify.countdown": {
      "desc": "description: "
  },
  "codecov.notify.delay": {
      "desc": "description: "
  },
  "codecov.notify.wait_for_ci": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.notify.require_ci_to_pass": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.notify": {
      "desc": "Configure how Codecov sends a PR comment"
  },
  "codecov.ui.hide_density": {
      "desc": "description: "
  },
  "codecov.ui.hide_complexity": {
      "desc": "description: "
  },
  "codecov.ui.hide_contexual": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.ui.hide_sunburst": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.ui.hide_search": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "codecov.ui": {
      "desc": "description: "
  },
  "codecov": {
      "desc": "description: Configure general codecov settings. More info: https://docs.codecov.com/docs/codecov-yaml"
  },
  "coverage.precision": {
      "desc": "min: 0, description: "
  },
  "coverage.precision.max": {
      "desc": 99
  },
  "coverage.round": {
      "desc": " down,  up,  nearest, description: "
  },
  "coverage.range": {
      "desc": "maxlength: 2, description: "
  },
  "coverage.notify.irc.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.irc.valuesrules.password": {
      "desc": "nullable: True"
  },
  "coverage.notify.irc.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.irc.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.irc.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.irc.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.irc.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.irc.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.irc": {
      "desc": "description: "
  },
  "coverage.notify.slack.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.slack.valuesrules.attachments.comma_separated_strings": {
      "desc": true
  },
  "coverage.notify.slack.valuesrules.attachments": {
      "desc": "nullable: True"
  },
  "coverage.notify.slack.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.slack.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.slack.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.slack.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.slack.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.slack.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.slack": {
      "desc": "description: "
  },
  "coverage.notify.gitter.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.gitter.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.gitter.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.gitter.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.gitter.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.gitter.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.gitter.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.gitter": {
      "desc": "description: "
  },
  "coverage.notify.hipchat.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.hipchat.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.hipchat.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.hipchat.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.hipchat.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.hipchat.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.hipchat.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.hipchat": {
      "desc": "description: "
  },
  "coverage.notify.webhook.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.webhook.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.webhook.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.webhook.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.webhook.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.webhook.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.webhook.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.webhook": {
      "desc": "description: "
  },
  "coverage.notify.email.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.notify.email.valuesrules.layout.comma_separated_strings": {
      "desc": true
  },
  "coverage.notify.email.valuesrules.layout": {
      "desc": "nullable: True"
  },
  "coverage.notify.email.valuesrules.url": {
      "desc": "nullable: True"
  },
  "coverage.notify.email.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.notify.email.valuesrules.threshold": {
      "desc": "nullable: True"
  },
  "coverage.notify.email.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.notify.email.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.notify.email.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.notify.email": {
      "desc": "description: "
  },
  "coverage.notify": {
      "desc": "description: "
  },
  "coverage.status.default_rules.flag_coverage_not_uploaded_behavior": {
      "desc": " include,  exclude,  pass, description: "
  },
  "coverage.status.default_rules.carryforward_behavior": {
      "desc": " include,  exclude,  pass, description: "
  },
  "coverage.status.default_rules": {
      "desc": "description: "
  },
  "coverage.status.project.keysrules": {
      "desc": "Title of the project status check. Using `default` will set title to blank"
  },
  "coverage.status.project.valuesrules": {
      "desc": "Contains the configuration for a given project status check. Setting to False will disable the project status check."
  },
  "coverage.status.project.valuesrules.target": {
      "desc": "Set the project status check to a number (80), percent (80%) or `auto`. This specifies the minimum coverage number accepted by this project status check. Setting to `auto` will compare coverage against the BASE commit."
  },
  "coverage.status.project.valuesrules.threshold": {
      "desc": "Allow coverage to drop by x% below the target and still pass the status check."
  },
  "coverage.status.project.valuesrules.flags": {
      "desc": "A list of user defined Flags to use for the status check. The combined coverage from those flags will be reported."
  },
  "coverage.status.project.valuesrules.branches": {
      "desc": "A list of the branches that, when used, will trigger this status."
  },
  "coverage.status.project.valuesrules.if_ci_failed": {
      "desc": "Options are `error` (default) and `success`. `error` will set the Codecov status to success only if the CI is also successful. `success` will set the Codecov status to success even if CI fails"
  },
  "coverage.status.project.valuesrules.if_not_found": {
      "desc": "Options are `success` (default) and `failure`. `success` will pass if there is no report for the HEAD commit. Use this on commits/PRs where you won't be uploading coverage but still want Codecov status checks to pass. `error` will fail if there is no report for the HEAD commit."
  },
  "coverage.status.project.valuesrules.measurement": {
      "desc": "Specify the type of coverage measurement. Options are `line`, `statement`, `branch`, `method`, `complexity`"
  },
  "coverage.status.project.valuesrules.removed_code_behavior": {
      "desc": "Specify the behavior if coverage drops due to code removal. Options are `removals_only`, `adjust_base`, `fully_covered_patch`, `off`, and `False`. See https://docs.codecov.com/docs/commit-status#removed_code_behavior for more details."
  },
  "coverage.status.project.valuesrules.paths": {
      "desc": "Similar to `flags`, a list of paths and/or regular expressions to use for the status check. The combined coverage from files that match will be reported."
  },
  "coverage.status.project.valuesrules.flag_coverage_not_uploaded_behavior": {
      "desc": "Determines how to handle status checks for which no flag coverage (including carryforward flags) has been newly uploaded on a commit. Options are: `include`: (default) All the status checks defined in the YAML file will be processed and sent as normal. `exclude`: Status checks that haven't newly uploaded any flag coverage will not be sent. `pass`: Status checks that haven't newly uploaded any flag coverage will be passed automatically. For information see https://docs.codecov.com/docs/commit-status#flag_coverage_not_uploaded_behavior"
  },
  "coverage.status.project": {
      "desc": "The configuration root for all project status checks in the repository."
  },
  "coverage.status.patch.keysrules": {
      "desc": "Title of the patch status check. Using `default` will set title to blank"
  },
  "coverage.status.patch.valuesrules": {
      "desc": "Contains the configuration for a given patch status check. Setting to False will disable the patch status check."
  },
  "coverage.status.patch.valuesrules.target": {
      "desc": "Set the patch status check to a number (80), percent (80%) or `auto`. This specifies the minimum coverage number accepted by this patch status check. Setting to `auto` will compare coverage against the BASE commit."
  },
  "coverage.status.patch.valuesrules.threshold": {
      "desc": "Allow coverage to drop by x% below the target and still pass the status check."
  },
  "coverage.status.patch.valuesrules.flags": {
      "desc": "A list of user defined Flags to use for the status check. The combined coverage from those flags will be reported."
  },
  "coverage.status.patch.valuesrules.branches": {
      "desc": "A list of the branches that, when used, will trigger this status."
  },
  "coverage.status.patch.valuesrules.if_ci_failed": {
      "desc": "Options are `error` (default) and `success`. `error` will set the Codecov status to success only if the CI is also successful. `success` will set the Codecov status to success even if CI fails"
  },
  "coverage.status.patch.valuesrules.if_not_found": {
      "desc": "Options are `success` (default) and `failure`. `success` will pass if there is no report for the HEAD commit. Use this on commits/PRs where you won't be uploading coverage but still want Codecov status checks to pass. `error` will fail if there is no report for the HEAD commit."
  },
  "coverage.status.patch.valuesrules.measurement": {
      "desc": "Specify the type of coverage measurement. Options are `line`, `statement`, `branch`, `method`, `complexity`"
  },
  "coverage.status.patch.valuesrules.removed_code_behavior": {
      "desc": "Specify the behavior if coverage drops due to code removal. Options are `removals_only`, `adjust_base`, `fully_covered_patch`, `off`, and `False`. See https://docs.codecov.com/docs/commit-status#removed_code_behavior for more details."
  },
  "coverage.status.patch.valuesrules.paths": {
      "desc": "Similar to `flags`, a list of paths and/or regular expressions to use for the status check. The combined coverage from files that match will be reported."
  },
  "coverage.status.patch.valuesrules.flag_coverage_not_uploaded_behavior": {
      "desc": "Determines how to handle status checks for which no flag coverage (including carryforward flags) has been newly uploaded on a commit. Options are: `include`: (default) All the status checks defined in the YAML file will be processed and sent as normal. `exclude`: Status checks that haven't newly uploaded any flag coverage will not be sent. `pass`: Status checks that haven't newly uploaded any flag coverage will be passed automatically. For information see https://docs.codecov.com/docs/commit-status#flag_coverage_not_uploaded_behavior"
  },
  "coverage.status.patch": {
      "desc": "The configuration root for all patch status checks in the repository."
  },
  "coverage.status.changes.keysrules": {
      "desc": "pattern: ^[\\w\\-\\.]+$"
  },
  "coverage.status.changes.valuesrules": {
      "desc": "nullable: True"
  },
  "coverage.status.changes.valuesrules.flags": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "coverage.status.changes.valuesrules.base": {
      "desc": " parent,  pr,  auto"
  },
  "coverage.status.changes.valuesrules.branches": {
      "desc": "nullable: True"
  },
  "coverage.status.changes.valuesrules.if_ci_failed": {
      "desc": " success,  failure,  error,  ignore"
  },
  "coverage.status.changes.valuesrules.if_no_uploads": {
      "desc": " success,  failure,  error,  ignore"
  },
  "coverage.status.changes.valuesrules.if_not_found": {
      "desc": " success,  failure,  error,  ignore"
  },
  "coverage.status.changes.valuesrules.measurement": {
      "desc": " line,  statement,  branch,  method,  complexity"
  },
  "coverage.status.changes.valuesrules.removed_code_behavior": {
      "desc": " removals_only,  adjust_base,  fully_covered_patch,  off,  False"
  },
  "coverage.status.changes.valuesrules.paths": {
      "desc": "nullable: True"
  },
  "coverage.status.changes.valuesrules.carryforward_behavior": {
      "desc": " include,  exclude,  pass"
  },
  "coverage.status.changes.valuesrules.flag_coverage_not_uploaded_behavior": {
      "desc": " include,  exclude,  pass"
  },
  "coverage.status.changes": {
      "desc": "description: "
  },
  "coverage.status.no_upload_behavior": {
      "desc": " pass,  fail, description: "
  },
  "coverage.status": {
      "desc": "description: "
  },
  "coverage": {
      "desc": "description: "
  },
  "parsers.go.partials_as_hits": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.go": {
      "desc": "description: "
  },
  "parsers.javascript.enable_partials": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.javascript": {
      "desc": "description: "
  },
  "parsers.v1.include_full_missed_files": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.v1": {
      "desc": "description: "
  },
  "parsers.gcov.branch_detection.conditional": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.gcov.branch_detection.loop": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.gcov.branch_detection.method": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.gcov.branch_detection.macro": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.gcov.branch_detection": {
      "desc": "description: "
  },
  "parsers.gcov": {
      "desc": "description: "
  },
  "parsers.jacoco.partials_as_hits": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "parsers.jacoco": {
      "desc": "description: "
  },
  "parsers": {
      "desc": "description: "
  },
  "ignore": {
      "desc": "description: "
  },
  "fixes": {
      "desc": "description: "
  },
  "flags.keysrules": {
      "desc": "minlength: 1, maxlength: 45, pattern: ^[\\w\\.\\-]+$"
  },
  "flags.valuesrules.carryforward_mode": {
      "desc": " all,  labels"
  },
  "flags.valuesrules.ignore": {
      "desc": "Ignore coverage for specific lines of code. You can provide a comma-separated list of line ranges or individual line numbers to be ignored."
  },
  "flags.valuesrules.paths": {
      "desc": "Are used to define the paths to your project's source files or directories for which you want to generate code coverage reports."
  },
  "flags.valuesrules.assume.branches": {
      "desc": "Customize how branches are treated in the code coverage analysis."
  },
  "flags.valuesrules.after_n_builds": {
      "desc": "Value rules after N builds refer to coverage requirements or thresholds that are applied after a certain number of builds or iterations."
  },
  "flags": {
      "desc": "Flags are typically used to customize the behavior of Codecov during the code coverage analysis process."
  },
  "flag_management.default_rules.statuses": {
      "desc": "Flag management rule statuses refer to the different states or conditions associated with flag management rules."
  },
  "flag_management.default_rules.carryforward_mode": {
      "desc": "Reference of past coverage for tests that are not run on current commit."
  },
  "flag_management.default_rules.carryforward": {
      "desc": "Carryforward Flags are designed for projects that do not upload total coverage for every commit. Users can define the following states for flags: True,  False,  yes,  no,  on,  off."
  },
  "flag_management.default_rules.paths": {
      "desc": "Define rules that specify conditions and actions for flag management. These rules can be based on various criteria such as coverage thresholds, branch names, commit messages, or other factors relevant to your project."
  },
  "flag_management.default_rules.ignore": {
      "desc": "To ignore or exclude specific files, directories, or patterns from flag management actions, you can define a flag management rule with conditions that exclude those specific elements."
  },
  "flag_management.default_rules.after_n_builds": {
      "desc": "Refers to the ability to apply specific flag management rules after a certain number of builds or iterations. Gradually enforce stricter or different flag management behavior as your project progresses over time."
  },
  "flag_management.default_rules": {
      "desc": "Rules are a set of defined conditions and actions that control the behavior of flags during the code coverage analysis process."
  },
  "flag_management.individual_flags": {
      "desc": "Individual flags refer to specific configuration options or settings that can be used to customize the behavior of the code coverage reporting and analysis process."
  },
  "flag_management": {
      "desc": "Allows you to control the behavior of flags during the code coverage analysis process."
  },
  "component_management.default_rules.statuses": {
      "desc": "Component management rule statuses refer to the different states or conditions associated with component management rules."
  },
  "component_management.default_rules.flag_regexes": {
      "desc": "Refers to the use of regular expressions to define patterns for matching specific flags or conditions during the code coverage analysis process."
  },
  "component_management.default_rules.paths": {
      "desc": "Define rules that specify conditions and actions for component management. These rules can be based on various criteria such as coverage thresholds, branch names, commit messages, or other factors relevant to your project."
  },
  "component_management.default_rules": {
      "desc": "Rules are a set of defined conditions and actions that control the behavior of components during the code coverage analysis process."
  },
  "component_management.individual_components": {
      "desc": "Individual components refer to specific configuration options or settings that can be used to customize the behavior of the code coverage reporting and analysis process."
  },
  "component_management": {
      "desc": "Use components you specify to create custom statuses and get coverage information from parts of your code that are not easily broken up into different uploads or span multiple flag groups."
  },
  "comment.layout.comma_separated_strings": {
      "desc": true
  },
  "comment.layout": {
      "desc": "Comment layout refers to the structure and formatting of the comments generated during the code coverage analysis process. The layout of comments can vary depending on the specific features and configurations of Codecov, as well as the platform or integration being used."
  },
  "comment.require_changes": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment.require_base": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment.require_head": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment.show_critical_paths": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment.branches": {
      "desc": "Comment branches refer to the specific branches or conditions under which comments are generated during the code coverage analysis. These comments provide feedback, suggestions, or information related to code coverage for specific branches of your codebase."
  },
  "comment.branches.items": {
      "desc": "nullable: True"
  },
  "comment.paths": {
      "desc": "Comment paths refer to the specific locations within your codebase where comments are added to provide feedback or information related to code coverage analysis. Comment paths can be associated with individual lines of code, code sections, or specific files."
  },
  "comment.flags": {
      "desc": "Comment flags refer to special markers or indicators that can be added to comments in your code to control the behavior of Codecov's code coverage analysis."
  },
  "comment.flags.items": {
      "desc": "pattern: ^[\\w\\.\\-]{1,45}$"
  },
  "comment.behavior": {
      "desc": " default,  once,  new,  spammy, description: "
  },
  "comment.after_n_builds": {
      "desc": "min: 0, description: "
  },
  "comment.show_carryforward_flags": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment.hide_comment_details": {
      "desc": " True,  False,  yes,  no,  on,  off"
  },
  "comment": {
      "desc": "Refer to the feedback or remarks that Codecov can provide on your code coverage results. These comments are typically added to pull requests or specific lines of code to provide additional information or suggestions regarding the code coverage analysis."
  },
  "github_checks.annotations": {
      "desc": "Checks enable users to see inline code annotations for contributed code on a PR that was not covered by tests, making it much easier for developers to see uncovered code contributions without leaving the GitHub PR."
  },
  "github_checks": {
      "desc": "Display code coverage information and analysis results directly within the GitHub interface. "
  },
  "profiling.fixes": {
      "desc": "description: "
  },
  "profiling.grouping_attributes": {
      "desc": "description: "
  },
  "profiling.critical_files_paths": {
      "desc": "description: "
  },
  "profiling": {
      "desc": "description: "
  },
  "beta_groups": {
      "desc": "description: "
  }
}
